

- 可变与不可变
- 各种内置操作


# 字符串算法

1. BF(Brute Force) 算法，暴力匹配、朴素匹配
字符串 A 中查找字符串 B，那字符串 A 就是**主串**，字符串 B 就是**模式串**；
遍历主串 A ，检查 A[i:i+len(B)] 是否等于 B；
在极端情况下，比如主串是“aaaaa…aaaaaa”，模式串是“aaaaab”。每次都比对 m 个字符，要比对 n-m+1 次，所以，这种算法的最坏情况时间复杂度是 O(n*m)；
实际软件开发常用：简单；大部分情况下，A 和 B 长度不会太长，每次匹配，中途遇见不匹配字符即停止，不需要比较 m 次，


2. RF(Rabin-Karp)算法
通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小；而不用比较子串的每个字符；
哈希算法设计：假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串； K 进制数转化成十进制数，作为子串的哈希值；
比如要处理的字符串只包含 a～z 这 26 个小写字母：
```
cba = c*26^2 + b*26 + a*1
    = 2*26^2 + 1*26 + 0*1 = 1353

bad =       b*26^2 + a*26 + d*1
    =       1*26^2 + 0*26 + 3*1
```
连续的子串对应的哈希值计算公式有交集：h[i] = (h[i-1] - 26^(m-1)*idx(s[i-1])) + 26^0 * idx(s[i+m-1]);
可以预先将 26^(m-1) 储存在长度为 m 的数组中；
时间复杂度：扫描一遍 O(n)，每次比较 O(1)，总共 O(n)
当模式串很长时，哈希算法得到的哈希值会很大，超过计算机整型范围；
此时允许哈希冲突，当哈希值相等时，再比较子串和模式串本身；

二维字符串矩阵的比较：
```
主串：          模式串：
dabc           ca
efad           ef
ccaf
defc
```

3. BM(Boyer-Moore) 算法：
   按照模式串下标从大到小倒着匹配的：
   - 坏字符规则：
     - 倒着匹配时，无法匹配的字符为坏字符；
     - 再在模式串中查找该坏字符，找不到时，整个模式串直接跳到坏字符后；
     - 找到了，就直接跳到模式串中该字符的位置处
     - 利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)
     - 但当 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。
    - 好后缀规则：
      - 坏字符后面可能还有已匹配的子串，称为好后缀
      - 再在模式串中查找该子串，找到，模式串即滑动到对应的位置
      - 找不到，若跳到好后缀后，此时可能导致过度滑动
      - 模式串前缀与好后缀重合时，可能完全匹配



4. KMP(Knuth-Morris-Pratt) 算法
   




